import os
import time
import pyaudio
from typing import Optional

from daisys import DaisysAPI
from daisys.v1.speak import (
    DaisysWebsocketGenerateError,
    Status,
    TakeResponse,
    StreamOptions,
    StreamMode,
)

from utils import throw_mcp_error


email = os.environ.get("DAISYS_EMAIL")
password = os.environ.get("DAISYS_PASSWORD")


def text_to_speech_websocket(text: str, voice_id: Optional[str] = None):
    """
    Generate and play audio from text using DaisysAPI's websocket protocol in a streamed fashion.
    """

    if not email or not password:
        raise ValueError(
            "DAISYS_EMAIL and DAISYS_PASSWORD environment variables must be set."
        )

    audio_player = pyaudio.PyAudio()
    stream = audio_player.open(
        format=pyaudio.paInt16,  # 16-bit PCM
        channels=1,  # Mono (Daisys default)
        rate=22050,  # Daisys default sample rate (verify if needed)
        output=True,
    )
    with DaisysAPI("speak", email=email, password=password) as speak:
        print("Found Daisys Speak API", speak.version())

        # A buffer to receive parts; we initialize with a single empty bytes()
        # because we will use it to accumulate chunks of the current wav file
        # there.  In total we will end with a list of wav files, one for each
        # part.  Parts are bits of speech, usually full sentences, that end with
        # silence.
        audio_wavs = [bytes()]

        # Assume at least one voice is available
        if not voice_id:
            try:
                voice_id = speak.get_voices()[-1].voice_id
            except IndexError:
                throw_mcp_error(
                    "No voices available try to generate a voice with the voice_generate."
                )

        with speak.websocket(voice_id=voice_id) as ws:
            # Flags we can use to only wait on our one take request; we wait
            # until the take is READY, and we also wait until we are done
            # receive all audio parts.
            done = False
            ready = False

            # Time the latency from when we submit the request until each part
            # is received.
            t0 = time.time()

            # The audio callback receives "parts" consisting of audio .wav files
            # with WAV headers on each part.  Depending on the stream settings,
            # the file may be divided into chunks, where chunk_id==None indicates
            # the last chunk of a part.  If audio==None, then no more parts will
            # arrive for that take_id.
            def audio_cb(
                request_id: int,
                take_id: str,
                part_id: int,
                chunk_id: Optional[int],
                audio: Optional[bytes],
            ):
                nonlocal done

                # Report timing info and function arguments
                print(
                    f"[{time.time()-t0:0.3f}s] Received {part_id=} ({chunk_id=}) for {take_id=} "
                    "with audio length",
                    len(audio) if audio else "(empty -- done receiving)",
                )

                # We only requested one take_id; the take_id is generated by the
                # Daisys API, so we do not know it until the first status
                # message arrives.  Therefore we can check that the request_id
                # is the expected one.
                assert request_id == generate_request_id
                assert generated_take is None or take_id == generated_take.take_id

                if audio is None:
                    # If stream is done for this part
                    if chunk_id in [0, None]:
                        # If we have any audio data, write out the last file
                        if len(audio_wavs[-1]) > 0:
                            stream.write(audio_wavs[-1])
                        # Flag that we are done receiving audio
                        done = True

                    # If we are receiving the last chunk of a part
                    elif chunk_id > 0:
                        stream.write(audio_wavs[-1])

                        # Start a new part
                        audio_wavs.append(bytes())

                # Otherwise append the chunk.
                else:
                    audio_wavs[-1] = audio_wavs[-1] + audio

                    # If non-chunked stream, the part is ended immediately
                    if chunk_id is None:
                        # If we have any audio data, write out the file

                        stream.write(audio_wavs[-1])

                        # Start a new part
                        audio_wavs.append(bytes())

            # The status callback is called every time the take's status
            # changes.  Here we use it to end the update loop.
            def status_cb(request_id: int, take: TakeResponse):
                nonlocal ready, generated_take
                assert request_id == generate_request_id
                generated_take = take
                print(take.status)
                if take.status == Status.READY:
                    ready = True

            # Submit a request to generate a take over the websocket connection.
            generate_request_id = ws.generate_take(
                voice_id=voice_id,
                text=text,
                status_callback=status_cb,
                audio_callback=audio_cb,
                # Optional
                stream_options=StreamOptions(mode=StreamMode.CHUNKS),
            )

            # Will be filled in by callbacks. On submitting the generate
            # request, we do not yet know what take_id will be assigned so we
            # must discover it by means of the status callback.
            generated_take = None

            # We loop on the websocket while waiting 5 seconds between updates,
            # and end when the take as been set to READY and all audio has been
            # received. This update waits 1 second by default, here we set to 5
            # seconds, but it can also wait forever by setting timeout to None
            # or be made a non-blocking operation by setting timeout to 0.
            # (Important: in async client, timeout=0 leads to TimeoutError, it
            # cannot be used for non-blocking operations with asyncio.)
            while not (ready and done) and (time.time() - t0) < 60:
                try:
                    ws.update(timeout=5)
                except DaisysWebsocketGenerateError as e:
                    # As opposed to other websocket errors, if a generate error
                    # occurs it does not necessarily mean we want to close the
                    # stream.
                    print(e)

                    # In this example, however, we actually do, because we only
                    # requested a single take, so stop here.
                    break

        # Delete the take
        if generated_take:
            print(
                f"Deleting take {generated_take.take_id}:",
                speak.delete_take(generated_take.take_id),
            )
        stream.stop_stream()
        stream.close()
        audio_player.terminate()
